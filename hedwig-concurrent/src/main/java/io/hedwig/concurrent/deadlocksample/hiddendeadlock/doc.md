参考代码一，考虑下面的过程： 

  ◆ 一个线程（ThreadA）调用method1()。 

  ◆ ThreadA在lock_1上同步，但允许被抢先执行。 

  ◆ 另一个线程（ThreadB）开始执行。 

  ◆ ThreadB调用method2()。 

  ◆ ThreadB获得lock_2，继续执行，企图获得lock_1。但ThreadB不能获得lock_1，因为ThreadA占有lock_1。 

  ◆ 现在，ThreadB阻塞，因为它在等待ThreadA释放lock_1。 

  ◆ 现在轮到ThreadA继续执行。ThreadA试图获得lock_2，但不能成功，因为lock_2已经被ThreadB占有了。 

  ◆ ThreadA和ThreadB都被阻塞，程序死锁。 

  当然，大多数的死锁不会这么显而易见，需要仔细分析代码才能看出，对于规模较大的多线程程序来说尤其如此。好的线程分析工具，例如JProbe Threadalyzer能够分析死锁并指出产生问题的代码位置。 

  隐性死锁 

  隐性死锁由于不规范的编程方式引起，但不一定每次测试运行时都会出现程序死锁的情形。由于这个原因，一些隐性死锁可能要到应用正式发布之后才会被发现，因此它的危害性比普通死锁更大。下面介绍两种导致隐性死锁的情况：加锁次序和占有并等待。 

  加锁次序 

  当多个并发的线程分别试图同时占有两个锁时，会出现加锁次序冲突的情形。如果一个线程占有了另一个线程必需的锁，就有可能出现死锁。考虑下面的情形，ThreadA和ThreadB两个线程分别需要同时拥有lock_1、lock_2两个锁，加锁过程可能如下： 

  ◆ ThreadA获得lock_1； 

  ◆ ThreadA被抢占，VM调度程序转到ThreadB； 

  ◆ ThreadB获得lock_2； 

  ◆ ThreadB被抢占，VM调度程序转到ThreadA； 

  ◆ ThreadA试图获得lock_2，但lock_2被ThreadB占有，所以ThreadA阻塞； 

  ◆ 调度程序转到ThreadB； 

  ◆ ThreadB试图获得lock_1，但lock_1被ThreadA占有，所以ThreadB阻塞； 

  ◆ ThreadA和ThreadB死锁。 

  必须指出的是，在代码丝毫不做变动的情况下，有些时候上述死锁过程不会出现，VM调度程序可能让其中一个线程同时获得lock_1和lock_2两个锁，即线程获取两个锁的过程没有被中断。在这种情形下，常规的死锁检测很难确定错误所在。 

  占有并等待 

  如果一个线程获得了一个锁之后还要等待来自另一个线程的通知，可能出现另一种隐性死锁，考虑代码二
  
  在代码二中，Producer向队列加入一项新的内容后通知Consumer，以便它处理新的内容。问题在于，Consumer可能保持加在队列上的锁，阻止Producer访问队列，甚至在Consumer等待Producer的通知时也会继续保持锁。这样，由于Producer不能向队列添加新的内容，而Consumer却在等待Producer加入新内容的通知，结果就导致了死锁。 
  
    在等待时占有的锁是一种隐性的死锁，这是因为事情可能按照比较理想的情况发展—Producer线程不需要被Consumer占据的锁。尽管如此，除非有绝对可靠的理由肯定Producer线程永远不需要该锁，否则这种编程方式仍是不安全的。有时“占有并等待”还可能引发一连串的线程等待，例如，线程A占有线程B需要的锁并等待，而线程B又占有线程C需要的锁并等待等。 
  
    要改正代码二的错误，只需修改Consumer类，把wait()移出“synchronized”()即可。 
  
    因此避免死锁的一个通用的经验法则是:当几个线程都要访问共享资源A、B、C时，保证使每个线程都按照同样的顺序去访问它们，比如都先访问A，在访问B和C。 
    此外，Thread类的suspend()方法也很容易导致死锁,因此这个方法已经被废弃了. 
